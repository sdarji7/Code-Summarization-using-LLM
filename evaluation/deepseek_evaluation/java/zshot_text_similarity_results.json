[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Zero-Shot",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value.",
        "deepseek_summary": "<think>\nOkay, so the user has provided a function called check that's supposed to validate some kind of hash. It looks like it's part of an encryption algorithm they might be using, maybe something similar to PBKDF2 or something with salt.\n\nFirst, I need to understand what this function is doing. The parameters are passed as strings, and it splits the 'hashed' string on \"$\". Then it checks if the resulting parts have a length of 5 and that the second part is \"s0\". If not, it throws an exception. That seems like a specific condition they're checking for.\n\nLooking at what's inside, after splitting, parts[2] is parsed as a long in hex. So 's0' must be a string value. Then parts[3] and [4] are decoded into byte arrays. These bytes are used with some parameters N, r, p, which are derived from the length of the 's0' part.\n\nThe next step is to pass the password (converted to UTF-8 bytes) through SCrypt.scrypt with a salt parameter that's the parts[3] array. Then it calculates an XOR sum of each byte and checks if it equals zero. That makes me think this function might be verifying a checksum after encryption, perhaps for integrity.\n\nNow, about the user's query: they want a short one-liner comment in one sentence. So I need to summarize what this function does concisely.\n\nI should mention that it splits the hashed string, checks parts, parses them as hex, calculates N from params, and uses them with SCrypt.scrypt to check if the derived hashes are equal after XORing.\n\nI also need to note potential exceptions for UTF-8 or SHA1PRNG issues. So the comment should cover both the functionality and error handling.\n</think>\n\nThis function splits a hashed string on \"$\", verifies parts of it, parses hex values, calculates parameters, decodes bytes into salt, and checks if derived hashes match after XORing with the password in UTF-8 format.",
        "BLEU": 0.0,
        "METEOR": 0.1011,
        "ROUGE-L": 0.0788
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Zero-Shot",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected.",
        "deepseek_summary": "<think>\nAlright, I'm trying to understand this function. It's supposed to detect a platform based on the architecture and name. Let me go through it step by step.\n\nFirst, the function `detect()` is declared as public static and throws an exception of type `UnsupportedPlatformException`. That makes sense because it's handling unexpected platforms.\n\nThe first two lines get the architecture (`os.arch`) and the OS name (`os.name`). So that part seems straightforward.\n\nNext, there's a for-each loop over `Arch.values()`, which is an enumeration of all possible architectures. For each arch, it checks if the pattern matches `os Arch`. If it does, another inner loop goes through all `OS.values()`, checking if the OS name matches `osName`.\n\nWhen both conditions are met, it returns a new Platform instance with the given architecture and OS name. That logic seems to make sense for platform detection.\n\nHowever, after the loops finish without returning, it constructs a message indicating that the detected platform is unsupported and throws an exception. So if none of the expected architectures or OS names match, it catches this and throws the exception.\n\nWait, but I'm not sure if `OS` here refers to something specific in this context. Maybe it's another term for architecture? Or maybe it's a misnomer. Also, in Java EE platforms, sometimes you have packages instead of OS objects. Could that be an issue here?\n\nAnother thing: the function is declared as returning `Object`, but the implementation returns a `Platform` object. I should check if the return type matches the implementation.\n\nAdditionally, I'm thinking about exceptions thrown during platform detection. If this function is part of a framework or library, are there any specific error handling considerations? For example, is it possible for this function to never be called with valid values?\n\nAlso, maybe the loop can be optimized by combining the checks into a single condition. That would make the code cleaner and more efficient.\n\nOverall, I think the function correctly detects supported platforms but could use some minor tweaks for clarity and optimization.\n</think>\n\nThe function `detect()` iterates through all possible architectures to find an architecture that matches the OS architecture and then checks against each OS object to see if its name matches. If a match is found, it returns a new Platform instance with those values. Otherwise, it throws an exception.\n\n**Step-by-step explanation:**\n1. The function starts by fetching `os.arch` (OS architecture) and `os.name` (OS name).\n2. It loops over all possible architectures.\n3. For each architecture, it checks if its pattern matches the fetched OS architecture.\n4. If a match is found, it proceeds to check against all OS objects for a matching OS name.\n5. If an OS object matches, returns a Platform instance with the given architecture and OS.\n6. If no match is found after checking all architectures and their respective OS instances:\n   - Constructs a message indicating unsupported platform.\n   - Throws `UnsupportedPlatformException` with that message.\n\nThis approach ensures that supported platforms are detected efficiently, while unknown ones trigger exceptions for clarity.",
        "BLEU": 0.0,
        "METEOR": 0.068,
        "ROUGE-L": 0.0599
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Zero-Shot",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key",
        "deepseek_summary": "<think>\nAlright, I need to respond to this user's query about generating a short comment for their function. The function is public <T> T getNodeMetaData(Object key) { ... }, and they want one sentence in the response.\n\nFirst, I'll look at what the function does. It's part of some object handling or maybe graph traversal code. The parameter 'key' is used to get metadata from a map called metaDataMap. If the map is null, it returns null; otherwise, it retrieves and returns the corresponding value as type T.\n\nSo, the main points are: the function uses a key to look up metadata, it checks if the map exists before accessing it, and handles the case where the map might be null.\n\nNow, how can I condense this into one concise comment? The user probably wants a quick understanding of what the function does without looking at the code. I should focus on the key parameter's role and the return behavior based on metaDataMap.\n\nI think mentioning that it returns T or null if metaDataMap is null would cover both possibilities. It clearly shows how the key is used to fetch data, so the comment should reflect that functionality concisely.\n</think>\n\nThe function retrieves metadata for a given key using `metaDataMap`, returning `T` or `null` if the map is null.",
        "BLEU": 0.0,
        "METEOR": 0.1225,
        "ROUGE-L": 0.0676
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Zero-Shot",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node",
        "deepseek_summary": "<think>\nOkay, so I need to write a short comment for this Java method. Let me look at the code again: it's a public void copyNodeMetaData function that takes another ASTNode as an argument.\n\nThe first line checks if other.metaDataMap is null. If it is, returns early. Then, if metaDataMap is null, it initializes a new ListHashMap and puts all of other's metadata into it.\n\nI want the comment to explain what this method does concisely. It copies the metadata from another node into the current metaDataMap. So I can say something like \"Copies metadata from another ASTNode to the current meta data map.\" That should capture the key functionality without being too verbose.\n</think>\n\nThe function `copyNodeMetaData` takes an `ASTNode` and copies its metadata into the current `metaDataMap`.\n\n```java\npublic void copyNodeMetaData(ASTNode other) {\n    if (other.metaDataMap == null) {\n        return;\n    }\n    if (metaDataMap == null) {\n        metaDataMap = new ListHashMap();\n    }\n    metaDataMap.putAll(other.metaDataMap);\n}\n```\n\n**Explanation:**\n- The method `copyNodeMetaData` takes another ASTNode as an argument.\n- It checks if the source node's metadata map (`other.metaDataMap`) is null. If it is, the method returns early without making changes.\n- Next, it creates a new `ListHashMap` if the current `metaDataMap` is also null and combines this newly created map with the metadata from the source node into `metaDataMap`.\n- The combined `metaDataMap` then contains all the metadata information from both the source and target nodes.",
        "BLEU": 0.0,
        "METEOR": 0.1992,
        "ROUGE-L": 0.1111
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Zero-Shot",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key",
        "deepseek_summary": "<think>\nOkay, so I need to create a short comment for this function. Let me see... The function is called setNodeMetaData and takes a key and value as parameters.\n\nFirst, the function checks if the key is null and throws an error if it is. That makes sense because you can't have a meta data with a null key.\n\nNext, it looks at the metaDataMap parameter. If it's null, it initializes it to a new ListHashMap(). So I should mention initializing the map or creating a new one here.\n\nThen there's this line: Object old = metaDataMap.put(key, value). That seems to add the key-value pair to the map. After that, if old isn't null, it throws another error about overwriting existing data. So after adding, we check if it was already present and throw an error in case of duplication.\n\nPutting this together, I want the comment to capture all the key actions: handling null keys, initializing the map when needed, putting the value into the map, and checking for duplicates before throwing exceptions.\n\nI should avoid any unnecessary details and focus on what's happening step by step. Maybe something like \"Sets node metadata with a given key-value pair, checks for null keys, ensures map is initialized when needed, adds the data, and throws an error if it was already present.\"\n\nDoes that cover everything? Yes, I think so. It explains each part clearly concisely.\n</think>\n\nSet node metadata with a given key-value pair, checks for null keys, ensures map is initialized when needed, adds the data, and throws an error if it was already present.",
        "BLEU": 0.0,
        "METEOR": 0.1998,
        "ROUGE-L": 0.1294
    }
]