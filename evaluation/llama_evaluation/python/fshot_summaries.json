[
    {
        "function": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `settext` function sets the text for a specific element. It takes two parameters: \n\n- `text`: The desired text to be displayed.\n- `cls`: An optional parameter specifying the class of the text, with 'current' as the default value.\n\nThe function uses another method, `replace`, to update the text content of an element associated with the given class.",
        "reference_summary": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element."
    },
    {
        "function": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `setdocument` function is used to associate a document with an element. \n\n- It checks if the provided `doc` is an instance of the `Document` class.\n- If no document is currently associated (`self.doc`), it sets the current element's document to be the provided one and checks for duplicate IDs.\n- The function then recursively calls itself on all child elements, setting their documents to the same provided document if they are instances of `AbstractElement`.",
        "reference_summary": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document."
    },
    {
        "function": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True",
        "prompt_type": "Few-Shot",
        "llama3_summary": "This function, `addable`, determines whether a new instance of a given class can be added to a parent element. It takes into account various constraints such as:\n\n* The total number of instances of the class that have already been added to the parent.\n* The maximum allowed number of instances for the class (defined by the `OCCURRENCES` property).\n* The presence of specific attributes required for the class (`REQUIRED_ATTRIBS`) and whether a set is being used (`set`).\n\nIf any of these constraints are not met, the function returns `False`. If the maximum instance limit is reached, it raises a `DuplicateAnnotationError` with an appropriate message.\n\nIn summary, this function acts as a gatekeeper to ensure that class instances are added to parents in a controlled and consistent manner.",
        "reference_summary": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError."
    },
    {
        "function": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `postappend` function is an internal method that performs additional checks after an element is added to another. It verifies the association of elements with a document, ensuring that all unassociated children are linked to the same document.\n\nIf an element was not previously associated with a document (i.e., it has no `doc` attribute), the function links it to its parent's document. Additionally, if the element has a valid `deepvalidation` setting on its document and is associated with a valid document, the function calls the `deepvalidation()` method.\n\n**Purpose**\n\nThe primary purpose of this function is to enforce data integrity by performing validation checks after an element is added, preventing inconsistent or invalid states in the system.",
        "reference_summary": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use."
    },
    {
        "function": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `updatetext` function updates a textual value within an element based on the text content of its children. It only supports elements that are instances of `TEXTCONTAINER`.\n\n**Key Features:**\n\n- Recomputes the textual value by concatenating the text content of child elements.\n- Supports both `AbstractElement` children with non-empty text and `isstring(child)` children with empty strings.\n- Updates the element's `data` attribute with a list containing the recomputed textual value.\n\n**Context**\nThis function appears to be part of a templating or formatting system, likely used in a web development context. The element being updated seems to be designed for rendering text content, and this function ensures that the text is up-to-date based on changes made by child elements.",
        "reference_summary": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``."
    }
]