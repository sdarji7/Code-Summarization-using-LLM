[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Expert",
        "llama3_summary": "This function, `check`, is designed to verify a password by comparing its hashed version with the provided hashed value. Here's how it works:\n\n**What the code does:**\n\n1. It takes two strings as input: `passwd` (the password to be verified) and `hashed` (the stored hashed value).\n2. It splits the `hashed` string into parts using a specific separator (`\\$`).\n3. It checks if the split parts are in the correct format:\n   - There should be exactly 5 parts.\n   - The second part should contain the string \"s0\".\n4. If the input is valid, it extracts the following values from the hashed parts:\n   - A salt value ( encoded as a hexadecimal number).\n   - The salt bytes themselves.\n   - Two sets of derived bytes using the SCrypt algorithm.\n5. It performs a bitwise XOR operation between the two sets of derived bytes to create an \"output\" hash.\n6. If the length of both derived byte arrays is equal, it returns true (passwords match). Otherwise, it returns false.\n\n**What's being used:**\n\n- The `SCrypt` algorithm is used for password hashing and derivation.\n- The function assumes that the stored hashed value has been generated using this same algorithm with the same parameters.\n- It uses Java's built-in `Long.parseLong`, `byte[]` manipulation, and XOR operations to perform these calculations.",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value.",
        "BERTScore": 0.6487
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Expert",
        "llama3_summary": "Here's a concise explanation of the function:\n\n**Function:** `detect()`\n\n**Purpose:** This function determines the operating system (OS) and its architecture.\n\n**How it works:**\n\n1. It retrieves two pieces of information from an environment variable:\n\t* `osArch`: The OS's architecture (e.g., x86, ARM).\n\t* `osName`: The name of the OS (e.g., Windows, Linux).\n2. It checks each possible combination of OS and architecture using a loop.\n3. If it finds a match between the retrieved information and one of the predefined combinations (stored in the `Arch` and `OS` enums), it creates a new `Platform` object with that OS and architecture.\n4. If no match is found, it throws an `UnsupportedPlatformException` with a message indicating that the platform is not supported.\n\n**Key points:**\n\n* The function uses predefined values (enums) for OS and architecture combinations to simplify the matching process.\n* It checks both `osArch` and `osName` to determine the full platform ID.\n* If no match is found, it throws an exception with a custom error message.",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected.",
        "BERTScore": 0.3875
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Expert",
        "llama3_summary": "Let's break down this function together.\n\nThis is a Java method called `getNodeMetaData`. It takes in an object `key` and returns a generic value of type `T`.\n\nHere's what it does:\n\n1. It first checks if there's a map stored in the variable `metaDataMap`.\n2. If the map is null, it simply returns null.\n3. If the map isn't null, it tries to retrieve a value from the map using the provided key.\n4. The returned value is then cast to type `T`, which means you can use it as if it's of type `T`.\n\nThink of this method like a dictionary lookup in Python. It searches for a specific \"key\" (object) in the `metaDataMap` and returns the associated value, wrapped in a generic object (`T`) that matches the type of the original key.\n\nFor example:\n\n```java\n// Let's say metaDataMap is a map with some values\nMap<String, Integer> myMap = new HashMap<>();\nmyMap.put(\"name\", 30);\n\n// Now we can use getNodeMetaData to get values from this map\nString name = getNodeMetaData(myMap.keySet().iterator().next());\nSystem.out.println(name); // prints \"30\"\n\nInteger age = getNodeMetaData(Integer::parseInt);\nSystem.out.println(age); // prints 30\n```\n\nThe benefit of using a generic type `T` is that you can use the method with different types of objects without having to manually cast them.",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key",
        "BERTScore": 0.3027
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Expert",
        "llama3_summary": "Let's break down this function together.\n\nThis function, `copyNodeMetaData`, is used to copy metadata from one `ASTNode` object (`other`) to the current object. Here's what it does:\n\n1. It checks if the other node has any metadata (a map-like data structure). If not, it simply returns.\n2. If the current node doesn't have a metadata map yet, it creates a new one.\n3. Then, it copies all the metadata from the `other` node into the current node's metadata map.\n\nIn essence, this function allows us to duplicate metadata from another node, making it easier to work with or clone nodes in our application. \n\nIt's like copying information from one file to another, where we want to preserve the same data structure and content.",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node",
        "BERTScore": 0.5197
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Expert",
        "llama3_summary": "This function is used to set metadata for an object in a tree-like structure. Here's what it does in detail:\n\n- It takes two parameters: `key` and `value`. The `key` represents the identifier of the node (like its name), and the `value` is the metadata associated with that node.\n\n- If the `key` is null, it throws an error because metadata keys cannot be null.\n\n- If the `metaDataMap` (a map that stores the metadata for all nodes) does not exist yet, it creates a new instance of `ListHashMap`.\n\n- Then it tries to add the `key-value` pair to the `metaDataMap`. \n\n- Before overwriting any existing metadata, it checks if there's already an old value associated with this key. If yes, it throws another error.\n\nIn essence, this function is used to store and manage metadata for nodes in a tree-like structure.",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key",
        "BERTScore": 0.3749
    }
]