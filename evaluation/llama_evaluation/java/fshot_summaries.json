[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary: Password Verification using SCrypt**\n\nThis function checks if a provided password matches a hashed password stored in the system. The hashing process involves:\n\n1.  Splitting the hashed string into parts\n2.  Converting the base-16 encoded `params` value to an integer representing the number of iterations (`N`) and some constants.\n3.  Decoding the salt bytes from the fourth part of the hashed string.\n4.  Computing the first derived key using SCrypt with the password, salt, and iteration count.\n5.  Verifying that both the original and derived keys have the same length.\n6.  Comparing bits between the two keys to determine if they match.\n\nIf any step fails or an exception occurs (e.g., UTF-8 encoding issue or JVM not supporting specific algorithms), the function throws an `IllegalStateException`. Otherwise, it returns a boolean indicating whether the password matches the hashed one.",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value."
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `detect()` function determines the current operating system (OS) and its architecture. It attempts to match the OS name and architecture against a predefined set of patterns.\n\n**What it does:**\n\n1. Retrieves the OS name and architecture using system properties (`os.arch` and `os.name`).\n2. Iterates through all possible combinations of architectures (`Arch.values()`) and operating systems (`OS.values()`).\n3. For each combination, it checks if the detected OS name matches a pattern in the corresponding enum value.\n4. If a match is found, it returns a new instance of `Platform` with the matched architecture and OS.\n5. If no match is found for any combination, it throws an `UnsupportedPlatformException` with a message indicating the unsupported platform (OS name and architecture).\n\n**Key Takeaways**\n\n* The function relies on predefined patterns to determine the OS and architecture, making it less flexible compared to other approaches.\n* It uses enums (`Arch` and `OS`) to define the possible architectures and operating systems, which can be extended or modified as needed.\n* The function throws an exception if it cannot determine the platform, providing a clear error message for debugging purposes.",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected."
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Few-Shot",
        "llama3_summary": "This function retrieves metadata associated with a given key from a map. \n\nSummary:\n\n* It takes an object as input and returns the corresponding metadata, which is stored in a map called `metaDataMap`.\n* If the key does not exist in the map, it returns null.\n* The function uses generics to ensure that the returned value matches the type specified in the method signature (`T`).\n \nNote: This code seems to be part of a larger class or interface that manages metadata for keys.",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key"
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Few-Shot",
        "llama3_summary": "Summary:\nThis function, `copyNodeMetaData`, copies metadata from another node (`other`) into the current node. It checks if the other node's metadata map is null and then either creates a new one or updates the existing one with all entries from the other node's metadata map.",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node"
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Few-Shot",
        "llama3_summary": "**Function Summary**\n\nThe `setNodeMetaData` function is used to set metadata for a node in the system. It takes two parameters: `key` and `value`, both of which are objects.\n\nHere's how it works:\n\n- If the `key` parameter is null, it throws a custom error with a message indicating that null keys cannot be used.\n- If no `metaDataMap` has been initialized (i.e., `metaDataMap` is null), it creates a new instance of `ListHashMap`.\n- It then attempts to add or update the metadata in the map using the `put` method, returning the old value associated with the key if one exists.\n- If an attempt is made to overwrite existing metadata (i.e., the returned value from `put` is not null), it throws a custom error.\n\nIn essence, this function provides a way to store and manage metadata for nodes in the system while preventing overwriting of existing data.",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key"
    }
]