[
    {
        "function": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the breakdown of the `settext` function for a junior developer:\n\n\"The `settext` function's purpose is to *update or create the text content* associated with this object. It takes the new text as input (`text`), and optionally a class name (`cls`). Think of the class name like a tag - it lets you have multiple pieces of text associated with the same element, as long as they have different class names.  By default, it uses the class 'current'. It works by finding any existing `TextContent` with the specified class, and either replacing its value with the new `text` *or* creating a new `TextContent` object if one doesn't exist with that class.\"",
        "reference_summary": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.",
        "BLEU": 0.0,
        "METEOR": 0.1934,
        "ROUGE-L": 0.1835
    },
    {
        "function": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the breakdown of the `setdocument` function for a junior developer:\n\n**Purpose:** This function links a FoLiA `Document` object to the current element and all its child elements. This is essential because every element in FoLiA needs to be part of a complete document.\n\n**How it works:**\n\n1. **Input:** It takes a `Document` object (`doc`) as input.\n2. **Type Check:**  It first makes sure you're actually passing a `Document` object using `assert isinstance(doc, Document)`. This helps prevent errors.\n3. **Initial Document Association:**\n   - It checks if the element already has a document associated (`if not self.doc`).\n   - If it doesn't, it sets `self.doc` to the input `doc`.\n   - It checks if the element has an ID (`if self.id`).\n   - If it has an ID, it registers the ID in the document's internal index to prevent duplicate IDs within the same document, raising `DuplicateIDError` if necessary.\n4. **Recursive Call:**  It then iterates through all the children of the current element (`for e in self`).  If a child is also a FoLiA element (`isinstance(e, AbstractElement)`), it recursively calls `setdocument` on that child, passing the same `doc`. This ensures that the entire tree of elements is linked to the same document.\n\n**In essence:** This function propagates the `Document` association down the element tree, making sure everything belongs to the same document and that IDs are unique. It's recursive to handle nested elements.",
        "reference_summary": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.",
        "BLEU": 0.0,
        "METEOR": 0.208,
        "ROUGE-L": 0.0671
    },
    {
        "function": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the breakdown of the `addable` function:\n\n**Purpose:** This function checks if you can add a new element of type `Class` to a `parent` element without violating any rules.  It's essentially a pre-check before actually adding something to a structure.\n\n**How it Works:**\n\n1. **`parent.accepts()` Check:** First, it calls the `accepts()` method of the `parent` class to see if the `parent` even *generally* allows the addition of this type of `Class`. If `accepts()` returns `False`, `addable()` immediately returns `False` (you can't add it).\n2. **`OCCURRENCES` Check:** If `Class` has a defined limit on the total number of occurrences (`Class.OCCURRENCES > 0`), it counts how many instances of `Class` already exist within the `parent`.  If the count is already at the limit, it either raises a `DuplicateAnnotationError` (if `raiseexceptions` is `True`) or returns `False`.\n3. **`OCCURRENCES_PER_SET` Check:**  If `Class` also has a limit on the number of occurrences *within a specific set* (`Class.OCCURRENCES_PER_SET > 0`) and a `set` is specified, it counts how many instances of `Class` already exist within the `parent` *for that specific set*. Again, if the count is at the limit, it raises an exception or returns `False`.\n4. **Return `True`:** If all checks pass, it means the new element can be added, and the function returns `True`.\n\n**In Simple Terms:**\n\nImagine you're building a structure (the `parent`). This function asks, \"Can I put another one of *this thing* (`Class`) here?\". It considers:\n\n*   Does the structure generally allow this *thing*? (`parent.accepts()`)\n*   Is there a limit to how many of *this thing* I can have in total?\n*   Is there a limit to how many of *this thing* I can have in a specific category (`set`)?\n\nIf all the answers are \"yes, you can\", then the function says, \"Go ahead, add it!\". Otherwise, it says, \"No, you can't, and I'll optionally tell you why with an error\".",
        "reference_summary": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError.",
        "BLEU": 0.0141,
        "METEOR": 0.195,
        "ROUGE-L": 0.1441
    },
    {
        "function": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the breakdown of the `postappend` function for a junior developer:\n\n\"The `postappend` function is called *after* an element is added as a child to another element. It's mainly for internal use.\n\nThink of it like a final sanity check.  Its primary jobs are:\n\n1.  **Document Association:** If the newly added element doesn't have a document associated with it yet, but its parent *does*, it automatically sets the element's document to be the same as the parent's. This ensures that all elements in the tree belong to the correct document. The `setdocument` method recursively sets the document for this element and all its children.\n2.  **Deep Validation:** If the document associated with the element has \"deep validation\" enabled, it calls the `deepvalidation` method. This performs a thorough check of the element's validity within the context of the document.\n\nEssentially, `postappend` makes sure the element is properly integrated into the document structure and valid before moving on.\"",
        "reference_summary": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.",
        "BLEU": 0.0335,
        "METEOR": 0.2988,
        "ROUGE-L": 0.2628
    },
    {
        "function": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's a simple breakdown of the `updatetext` function:\n\n\"This function updates the text content of an element by combining the text from its children.  It only works if the element is a `TEXTCONTAINER`.  It iterates through each child: if the child is another element (an `AbstractElement`), it first updates *that* child's text using `updatetext()` recursively, and then adds its text content (obtained via `child.text()`) to a running string. If the child is just a string, it adds that string directly. Finally, it stores the accumulated string as the element's new text content within its `data` list.\"",
        "reference_summary": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``.",
        "BLEU": 0.0296,
        "METEOR": 0.2371,
        "ROUGE-L": 0.1429
    }
]