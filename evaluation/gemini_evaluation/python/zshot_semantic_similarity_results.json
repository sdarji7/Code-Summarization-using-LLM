[
    {
        "function": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)",
        "prompt_type": "Zero-Shot",
        "gemini_summary": "This function replaces or sets the text content of an element, optionally specifying a class to ensure uniqueness.",
        "reference_summary": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.",
        "BERTScore": 0.5061
    },
    {
        "function": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)",
        "prompt_type": "Zero-Shot",
        "gemini_summary": "This function recursively associates a FoLiA document with an element and its children, raising an error if a duplicate ID is found.",
        "reference_summary": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.",
        "BERTScore": 0.5035
    },
    {
        "function": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True",
        "prompt_type": "Zero-Shot",
        "gemini_summary": "Checks if adding an instance of `Class` to `parent` is allowed based on occurrence limits and set constraints, raising an exception or returning `False` if not.",
        "reference_summary": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError.",
        "BERTScore": 0.6773
    },
    {
        "function": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()",
        "prompt_type": "Zero-Shot",
        "gemini_summary": "This function ensures document association and performs optional deep validation after an element is appended.",
        "reference_summary": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.",
        "BERTScore": 0.6611
    },
    {
        "function": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]",
        "prompt_type": "Zero-Shot",
        "gemini_summary": "This function recursively updates the text content of a TEXTCONTAINER element by concatenating the text content of its children.",
        "reference_summary": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``.",
        "BERTScore": 0.6725
    }
]