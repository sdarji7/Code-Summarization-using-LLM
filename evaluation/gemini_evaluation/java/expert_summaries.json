[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's a concise summary of the `check` function, explaining it for a junior developer:\n\n\"This function verifies a password against a pre-computed, scrypt-hashed password. It takes the plaintext password and the stored hash as input.\n\nHere's the breakdown:\n\n1.  **Hash Format Check:** It expects the hashed password to be in a specific format (`$s0$...`). It splits the hash string and validates the format (5 parts separated by '$', the second part must be 's0'). If the format is wrong, it throws an error.\n2.  **Parameter Extraction:** It extracts the parameters used in the scrypt hashing process (N, r, p) and the salt and derived key from the stored hash.  These parameters control the computational cost of scrypt, making it harder to crack.\n3.  **Scrypt Calculation:** It then uses the provided password and the extracted salt and parameters to re-compute the scrypt hash using the `SCrypt.scrypt` method.\n4.  **Comparison:** Finally, it compares the newly computed hash with the derived key stored in the provided hash using an XOR comparison.  If they match, it means the password is correct, and the function returns `true`; otherwise, it returns `false`.\n5.  **Error Handling:** The function also handles potential exceptions related to character encoding (UTF-8) and security algorithms.\n\nEssentially, this function is doing password authentication by re-hashing the provided password using the parameters stored within the existing hash and comparing the new derived key to the stored derived key.\n\"",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value."
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the breakdown of that `detect()` function:\n\n\"This Java function `detect()` determines the platform (OS and architecture) the code is running on.  It gets the OS architecture and name from system properties (`os.arch` and `os.name`).  Then, it iterates through predefined `Arch` and `OS` enums, checking if their respective patterns match the retrieved architecture and OS name. If a match is found for both, it creates and returns a `Platform` object representing that architecture and OS. If no match is found after checking all possible `Arch` and `OS` combinations, it throws an `UnsupportedPlatformException`, indicating the platform isn't supported.\"",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected."
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the summary:\n\n\"This Java function `getNodeMetaData` retrieves metadata associated with a given `key`. It checks if the `metaDataMap` (presumably a `Map` holding the metadata) is initialized. If it's `null` (meaning it hasn't been created or initialized), it returns `null`. Otherwise, it retrieves the value associated with the provided `key` from the `metaDataMap` and returns it, casting it to the type `T`. Effectively, it's a getter method for metadata stored in a map, handling the case where the map might not exist.\"",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key"
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's a summary of the `copyNodeMetaData` function:\n\n\"This function copies metadata (key-value pairs) from another ASTNode (`other`) to the current ASTNode. If the `other` node doesn't have any metadata, the function does nothing. If the current node doesn't have metadata yet, it creates a new `ListHashMap` to store it. Finally, it copies all the metadata from the `other` node's `metaDataMap` into the current node's `metaDataMap`.\"",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node"
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Expert",
        "gemini_summary": "Okay, here's the summary for the junior dev:\n\nThis Java function, `setNodeMetaData`, is used to store metadata (key-value pairs) associated with a node.  It's pretty straightforward:\n\n1.  **Null Key Check:** First, it makes sure the `key` you're trying to use isn't `null`. If it is, it throws an error because you can't have a metadata entry with a missing key.\n\n2.  **Initialize Metadata Map:** It checks if the `metaDataMap` (where the metadata is actually stored) exists. If it doesn't, it creates a new `ListHashMap` to hold the key-value pairs.\n\n3.  **Store the Metadata:** It then puts the `key` and `value` into the `metaDataMap`.\n\n4.  **Overwrite Check:**  Importantly, it verifies that you're not trying to overwrite existing metadata for the given `key`. If there was a value already associated with that key, it throws an error. This prevents accidentally changing existing metadata.\n\nIn short, it adds metadata to a node, ensuring that keys are valid and that you're not overwriting existing entries.  If something goes wrong, it throws a `GroovyBugError`.",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key"
    }
]