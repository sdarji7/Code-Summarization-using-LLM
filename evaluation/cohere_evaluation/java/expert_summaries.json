[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Expert",
        "cohere_summary": "Sure! Here's a concise summary of the `check` function for a junior developer:\n\nThe `check` function is used to validate a password against a hashed value. It takes two strings as input: `passwd` (the user-provided password) and `hashed` (the stored hashed value). The function uses the SCrypt password-based key derivation function to securely compare the provided password with the hashed value.\n\nHere's a step-by-step explanation:\n1. The `hashed` value is split into multiple parts using a delimiter \"\\\\$\".\n2. It checks if the hashed value has the correct format by verifying the length of the parts and comparing the second part with the expected value \"s0\".\n3. The function then extracts various parameters from the hashed value, including the log2 of iteration count (N), block size (r), and parallelization factor (p).\n4. It uses the SCrypt function to derive a key from the provided password, salt, and the extracted parameters.\n5. The derived key is compared with the key stored in the hashed value. If they have the same length and their XOR combination results in zero, the password is considered valid.\n\nThe function throws exceptions for unsupported character encodings or security functions, which should not occur in a properly configured JVM.\n\nOverall, this function provides a secure way to check if a provided password matches the stored hashed value, ensuring password security and integrity.",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value."
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Expert",
        "cohere_summary": "Here's a concise summary of the `detect` function for a junior developer:\n\n**Function Purpose:**\nThe `detect` function is used to identify the platform (operating system and architecture) that the Java program is running on. It returns an object of type `Platform` that encapsulates this information.\n\n**Function Logic:**\n1. The function retrieves the values of two system properties: \"os.arch\" (operating system architecture) and \"os.name\" (operating system name).\n2. It then iterates through a set of predefined architecture values (`Arch.values()`) and checks if the detected `os.arch` matches any of the patterns associated with those architectures.\n3. For each matching architecture, it further iterates through a set of predefined operating system values (`OS.values()`) and checks if the detected `os.name` matches any of the patterns associated with those operating systems.\n4. If a match is found for both architecture and operating system, a new `Platform` object is created and returned, encapsulating this information.\n5. If no match is found after iterating through all possible combinations, the function throws an `UnsupportedPlatformException` with an error message indicating the unsupported platform.\n\n**Exception Handling:**\nThe function throws an `UnsupportedPlatformException` if it fails to identify the platform based on the provided \"os.arch\" and \"os.name\" values. This exception should be caught and handled appropriately by the calling code.\n\n**Assumptions:**\nThis function assumes that the `Arch` and `OS` enums have predefined patterns that match the expected formats of \"os.arch\" and \"os.name\" values, respectively.\n\nOverall, this function provides a way to detect and identify the platform on which the Java program is running, and it throws an exception if the platform is not recognized or supported.",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected."
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Expert",
        "cohere_summary": "Here's a concise summary of the `getNodeMetaData` function for a junior developer:\n\n**Function Purpose:**\nThe `getNodeMetaData` function retrieves metadata associated with a given key from a metadata map.\n\n**Function Signature:**\n`public <T> T getNodeMetaData(Object key)`\n\n**Parameters:**\n- `key`: This is the identifier for which you want to retrieve the metadata. It can be any Java object.\n\n**Return Type:**\n- `<T>`: This method uses generics, allowing it to work with different types of metadata values. `T` represents the expected return type.\n\n**Function Behavior:**\n1. It first checks if the `metaDataMap` is null. If it is, the function returns null, indicating that no metadata is available.\n2. If the `metaDataMap` is not null, it retrieves the value associated with the given key and returns it as type `T`.\n\n**Example Usage:**\n```java\nObject key = \"myKey\";\nString metadata = getNodeMetaData(key);\nif (metadata != null) {\n    System.out.println(\"Metadata for key '\" + key + \"': \" + metadata);\n} else {\n    System.out.println(\"No metadata found for key '\" + key + \"'\");\n}\n```\n\nRemember to replace `<T>` with the appropriate type when calling the function, as it ensures type safety and avoids casting issues.",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key"
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Expert",
        "cohere_summary": "Sure! Here is a concise summary of the `copyNodeMetaData` function for a junior developer:\n\nThe `copyNodeMetaData` function is used to copy metadata associated with an AST (Abstract Syntax Tree) node. It takes another ASTNode object, `other`, as a parameter and updates the current node's metadata map. If the other node has metadata (i.e., `other.metaDataMap` is not null), it iterates through the key-value pairs in the other node's metadata map and puts them into the current node's metadata map, `metaDataMap`. If the current node's metadata map is null, a new empty map is created before copying the metadata. This function is likely used in a compiler or parser to propagate and manage metadata information during the analysis or transformation of AST nodes.",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node"
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Expert",
        "cohere_summary": "Sure! Here is a concise summary of the `setNodeMetaData` function for a junior developer:\n\nThe `setNodeMetaData` function is used to associate custom metadata with a specific node. It takes two parameters, `key` and `value`, which represent the identifier and the associated data, respectively. The function first checks if the key is valid (not null) and then interacts with a metadata map to store the provided key-value pair. If an entry with the same key already exists in the map, the function throws an error to prevent overwriting existing metadata. This function is useful for attaching additional information to nodes dynamically.",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key"
    }
]