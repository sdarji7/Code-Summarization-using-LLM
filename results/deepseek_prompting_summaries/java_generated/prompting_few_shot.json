[
    {
        "function": "public static boolean check(String passwd, String hashed) {\n        try {\n            String[] parts = hashed.split(\"\\\\$\");\n\n            if (parts.length != 5 || !parts[1].equals(\"s0\")) {\n                throw new IllegalArgumentException(\"Invalid hashed value\");\n            }\n\n            long params = Long.parseLong(parts[2], 16);\n            byte[] salt = decode(parts[3].toCharArray());\n            byte[] derived0 = decode(parts[4].toCharArray());\n\n            int N = (int) Math.pow(2, params >> 16 & 0xffff);\n            int r = (int) params >> 8 & 0xff;\n            int p = (int) params      & 0xff;\n\n            byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\n\n            if (derived0.length != derived1.length) return false;\n\n            int result = 0;\n            for (int i = 0; i < derived0.length; i++) {\n                result |= derived0[i] ^ derived1[i];\n            }\n            return result == 0;\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\n        }\n    }",
        "prompt_type": "Few-Shot",
        "reference_summary": "Compare the supplied plaintext password to a hashed password.\n\n@param   passwd  Plaintext password.\n@param   hashed  scrypt hashed password.\n\n@return true if passwd matches hashed value.",
        "deepseek_summary": "<think>\nOkay, I need to summarize the given Java function. Let me read through it step by step.\n\nThe function is called check and takes two String parameters: passwd and hashed. It's a static boolean method. The function does several things: it tries to process the hashed string, splits it using a delimiter, checks some conditions on the parts, parses some values as long, and then uses those values in an encryption algorithm.\n\nFirst, I'll look at what the hashed.split(\"\\\\$\") does. It splits the hashed string into an array parts using \\$ as the delimiter. So if the hash is something like \"s0:abc123$,def456\", it would split into [\"s0\", \"abc123$\", \"def456\"].\n\nThen, there's a condition checking if parts.length isn't 5 or if parts[1] doesn't equal \"s0\". If either is true, it throws an exception. So, the hash must have exactly five parts and the second part should be \"s0\".\n\nNext, parts[2], which is at index 2 in zero-based terms, is parsed as a long using base 16. That gives the salt value.\n\nSimilarly, parts[3] is decoded into a byte array. Then, parts[4] is also decoded into a byte array. \n\nAfter parsing these, there's some calculation for N: (int) Math.pow(2, params >> 16 & 0xffff). This shifts the params' 16th bit to get an exponent for 2^N.\n\nThen, r and p are derived from the lower bytes of params. These variables seem important for the cryptographic operation.\n\nThe function calls SCrypt.scrypt with several parameters: the password as a UTF-8 encoded byte array, salt, N, r, p, and 32 as the salt length limit.\n\nAfter that, it checks if the lengths of derived0 and derived1 are equal. If not, returns false.\n\nFinally, it initializes an integer result to 0 and XORs each corresponding byte in derived0 and derived1. If the result is all zeros, returns true; else, false.\n\nSo putting this together, the function seems to be doing a SHA-256 check using something like bcrypt or scrypt from Bcryptlib, which might handle password hashing with salt values. It extracts certain bytes from the hash parameters and compares them against those of the provided password.\n\nI should note that if any of the initial conditions fail (like parts length not being 5), it throws an exception. Also, it's using a try-catch for byte swap exceptions when running on the JVM without UTF-8 compatibility, but I don't think that's essential here since Java should handle it automatically.\n\nSo the function is performing a SHA256-based password check with some custom salt and iterations.\n</think>\n\nThe provided Java function `check(Stringpasswd, Stringhashed)` performs a SHA-256-based password verification using a custom salt method. Here's a concise breakdown of its functionality:\n\n1. **Input Handling**: It takes two strings as inputs: the password and hashed value.\n\n2. **Splitting the Hashed Value**: The hash is split using `$` to produce an array of parts. If not exactly five parts or if the second part isn't \"s0\", it throws an exception.\n\n3. **Parsing Parameters**:\n   - `params` is parsed as a long from base 16, representing the salt.\n   - `salt` and `password` are derived from byte arrays from parts[3] and 4 respectively.\n\n4. **Exponential Calculation**: `N` is calculated using `params >> 16 & 0xffff`.\n\n5. **XOR Check**: The function XORs corresponding bytes of the password-encoded-derived values for both hash and salt, comparing the result to zero.\n\nThe function returns `true` if all XOR results are zero (indicating a perfect match) or `false` otherwise."
    },
    {
        "function": "public static Platform detect() throws UnsupportedPlatformException {\n        String osArch = getProperty(\"os.arch\");\n        String osName = getProperty(\"os.name\");\n\n        for (Arch arch : Arch.values()) {\n            if (arch.pattern.matcher(osArch).matches()) {\n                for (OS os : OS.values()) {\n                    if (os.pattern.matcher(osName).matches()) {\n                        return new Platform(arch, os);\n                    }\n                }\n            }\n        }\n\n        String msg = String.format(\"Unsupported platform %s %s\", osArch, osName);\n        throw new UnsupportedPlatformException(msg);\n    }",
        "prompt_type": "Few-Shot",
        "reference_summary": "Attempt to detect the current platform.\n\n@return The current platform.\n\n@throws UnsupportedPlatformException if the platform cannot be detected.",
        "deepseek_summary": "<think>\nOkay, so I need to summarize this Java function. Let me read through it carefully.\n\nThe function is called detect and it's a public static method that throws an UnsupportedPlatformException. It doesn't take any parameters or return types except String, which makes sense because it returns the platform name.\n\nFirst, it gets property values for \"os.arch\" and \"os.name\". Then there's a loop over all entries in the Arch collection. For each arch value, if arch patterns match osArch, then it proceeds to check OS entries against osName.\n\nInside the nested loop, if either os matches the pattern for osName, it returns a new Platform instance with those parameters. If none of them work after checking all possibilities, it throws an exception with a message that's the formatted string combining the platform names.\n\nSo putting this together, the function seems to check specific platform patterns against known values to find a compatible one. It returns the first successful combination and otherwise throws an error if not found. The code is structured with nested loops, which means it tries all possible combinations of platforms until it finds one that fits.\n</think>\n\nThe function `detect()` takes properties for \"os.arch\" (arch) and \"os.name\" (name). It iterates through each platform entry to see if it matches the known architecture or name. If a match is found, it returns a new `Platform` instance with those parameters. If no match is found after checking all platforms, an `UnsupportedPlatformException` is thrown.\n\nThe function is structured as follows:\n\n1. Get properties for `os.arch` and `os.name`.\n2. Iterate over each platform entry to check if it matches the architecture or name.\n3. For matching arches, iterate over each OS entry to match the name.\n4. Return a new `Platform` instance upon finding a successful combination.\n5. If no matching platform is found after all iterations, throw an exception with the formatted error message.\n\nExample usage: The function would be used in code like:\n\n```java\nPlatform detected = detect(\n    getProperty(\"os/arch\"),\n    getProperty(\"osname\")\n);\n```\n\nThis example calls `detect` with the property values of \"os.arch\" and \"os.name\", which it uses to find a matching platform instance."
    },
    {
        "function": "public <T> T getNodeMetaData(Object key) {\n        if (metaDataMap == null) {\n            return (T) null;\n        }\n        return (T) metaDataMap.get(key);\n    }",
        "prompt_type": "Few-Shot",
        "reference_summary": "Gets the node meta data.\n\n@param key - the meta data key\n@return the node meta data value for this key",
        "deepseek_summary": "<think>\nAlright, let's see. The user provided two examples and a new function they want summarized. I need to figure out what the function is doing based on the examples.\n\nFirst example is an add function that takes two numbers and returns their sum. That makes sense\u2014adding two values together. So in the case of getNodeMetaData, if metaDataMap is null, it returns null; otherwise, it retrieves the value from metaDataMap using the key.\n\nLooking at the second example, reverse_string uses s[::-1], which reverses the string. But the user's function has a parameter T and returns a T type object. Wait, in their function, they return (T) metaDataMap.get(key). So if the key exists in metaDataMap, it returns that value as an instance of type T.\n\nSo putting it together, the getNodeMetaData function seems to check if metaDataMap is null; if so, it returns null. Otherwise, it retrieves the entry for the given key and returns it as an object of type T. That makes sense in the context where metaDataMap contains various types of data that can be returned by this method.\n\nI should explain that the function behaves like a default value provider: when the map isn't available (null), it falls back to the retrieved entry, preserving the return type as per the key's presence.\n</think>\n\nThe provided function `getNodeMetaData` appears to act as a simple lookup mechanism. Here's how it works:\n\n1. **Null Check**: The function first checks if `metaDataMap` is null. If it is, the function returns `(T) null`.\n2. **Default Case**: If `metaDataMap` is not null, the function retrieves the value associated with the given key from `metaDataMap`.\n3. **Return Type Preservation**: The retrieved value (if present in `metaDataMap`) will be returned as an object of type `T`, ensuring that the return type remains consistent.\n\nIn summary, `getNodeMetaData` acts as a fallback mechanism, returning a default value when no mapping is found, while preserving the expected return type based on the presence of data in `metaDataMap`."
    },
    {
        "function": "public void copyNodeMetaData(ASTNode other) {\n        if (other.metaDataMap == null) {\n            return;\n        }\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        metaDataMap.putAll(other.metaDataMap);\n    }",
        "prompt_type": "Few-Shot",
        "reference_summary": "Copies all node meta data from the other node to this one\n@param other - the other node",
        "deepseek_summary": "<think>\nOkay, I need to summarize the given function. Let me look at what it's doing.\n\nThe function is called copyNodeMetaData and takes an ASTNode as a parameter. \n\nFirst, there's an if statement checking if other.metaDataMap is null. If it is, the function returns immediately without making any changes. That makes sense because if one of the parameters is null, we don't need to do anything.\n\nNext, another if statement checks if metaDataMap is null. Since previously, we only set metaDataMap in that case, this seems like a catch-all condition for when it's not yet initialized. So, in that case, they create a new empty ListHashMap and assign it to metaDataMap.\n\nThen, they do a putAll on metaDataMap using other.metaDataMap. I think that means combining the data from 'other' into this new map. This is probably because the function's purpose is likely related to modifying or adding node metadata, and by using list-style maps, it allows for efficient merging of data.\n\nPutting it all together, the function seems to handle cases where either other.metaDataMap is null or metaDataMap hasn't been initialized yet by initializing metaDataMap and combining its contents with other's. This should make the code more robust in handling different scenarios without hardcoding.\n</think>\n\nThe function `copyNodeMetaData` modifies an `astroNode` based on another node's metadata. Here's how it works:\n\n1. **Check for null parameter**: If either `other.metaDataMap` or `metaDataMap` is `null`, the function returns immediately, meaning no further action is taken.\n2. **Initialize metaDataMap if not set**: If neither parameter is `null`, the function initializes an empty list-style map (`ListHashMap`) and sets it to `metaDataMap`.\n3. **Merge metadata from other node**: The function copies all the metadata from `other.metaDataMap` into the initialized `metaDataMap`. This effectively merges or updates the metadata of the target `node`.\n\nThis approach ensures that the function can handle different scenarios without hardcoding, making it more flexible and robust."
    },
    {
        "function": "public void setNodeMetaData(Object key, Object value) {\n        if (key==null) throw new GroovyBugError(\"Tried to set meta data with null key on \"+this+\".\");\n        if (metaDataMap == null) {\n            metaDataMap = new ListHashMap();\n        }\n        Object old = metaDataMap.put(key,value);\n        if (old!=null) throw new GroovyBugError(\"Tried to overwrite existing meta data \"+this+\".\");\n    }",
        "prompt_type": "Few-Shot",
        "reference_summary": "Sets the node meta data.\n\n@param key - the meta data key\n@param value - the meta data value\n@throws GroovyBugError if key is null or there is already meta\ndata under that key",
        "deepseek_summary": "<think>\nOkay, so I need to summarize this function. Let me read it carefully.\n\nThe function is called setNodeMetaData and it takes a key and a value as parameters. It's supposed to set some metadata for a node in something probably related to graph traversal or similar structures.\n\nFirst, the code checks if the key is null. If it is, it throws an error saying that trying to set meta data with a null key on this object. That makes sense because you can't use a null key. So I should mention that in the summary.\n\nThen there's a check for when metaDataMap is null. If it is, they create a new ListHashMap and assign it to metaDataMap. I think that's probably a custom data structure or class named ListHashMap since it's not part of standard Java libraries unless it's specific here. So I should mention creating an instance if the map is null.\n\nAfter that, it gets the old value by calling put with key and value from the map. Then checks if old isn't null to throw another error about overwriting existing metadata. This ensures that each call only updates the map without replacing previous entries.\n\nSo putting this all together, the function seems to be a method that sets a node's metadata using a key-value pair. It handles edge cases like when the key is null or the map is already present. The exceptions thrown will help catch any bugs in how the metadata is being set.\n</think>\n\nThe function `setNodeMetaData` is designed to set metadata for a node, taking into account certain edge cases.\n\n1. **Null Key Check**: If the provided key is `null`, it throws a `GroovyBugError` indicating that setting meta data with a null key on this object would cause an error.\n2. **Null MetaDataMap Handling**: If the existing `metaDataMap` instance is `null`, it initializes and assigns a new `ListHashMap`.\n3. **Update Metadata**: It retrieves the metadata using the provided key-value pair from the map. If the metadata value exists, it throws another exception to prevent overwriting existing data.\n4. **Exception Handling**: Both exceptions ensure that the function correctly handles cases where keys are null or when metadata is already set.\n\nIn summary, this method safely updates node metadata while managing edge cases related to null values and existing data entries."
    }
]